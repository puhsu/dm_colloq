\documentclass[a4paper,12pt]{article}

%% Начало шапки

%% Настройка поддержки русского языка
\usepackage{cmap}                   % Поиск по кириллице
\usepackage{mathtext}               % Кириллица в формулах
\usepackage[T1,T2A]{fontenc}        % Кодировки шрифтов
\usepackage[utf8]{inputenc}         % Кодировка текста
\usepackage[english,russian]{babel} % Подключение поддержки языков

%% Настройка размеров полей
\usepackage[top=0.7in, bottom=0.75in, left=0.625in, right=0.625in]{geometry}

%% Математические пакеты
\usepackage{mathtools}              % Тот же amsmath, только с некоторыми поправками
\usepackage{amssymb}                % Математические символы
\usepackage{amsthm}                 % Оформление теорем
\usepackage{amstext}                % Текстовые вставки в формулы
\usepackage{amsfonts}               % Математические шрифты
\usepackage{icomma}                 % "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление
\usepackage{enumitem}               % Для выравнивания itemize (\begin{itemize}[align=left])
\usepackage{array}                  % Таблицы и матрицы
\usepackage{multirow}

%% Алгоритмические пакеты и их настройки
\usepackage{algorithm}              % Шапка алгоритма
\usepackage{algorithmicx}           % Написание алгоритмов
\usepackage[noend]{algpseudocode}   % Написание псевдокода; убраны end
\usepackage{listings}               % Для кода на каком-либо языке программиования
\renewcommand{\algorithmicrequire}{\textbf{Ввод:}}              % Ввод
\renewcommand{\algorithmicensure}{\textbf{Вывод:}}              % Вывод
\floatname{algorithm}{Алгоритм}                                 % Название алгоритма
\renewcommand{\algorithmiccomment}[1]{\hspace*{\fill}\{// #1\}} % Комментарии
\newcommand{\algname}[1]{\textsc{#1}}                           % Вызов функции в алгоритме

\newcommand*{\hm}[1]{#1\nobreak\discretionary{}
	{\hbox{$\mathsurround=0pt #1$}}{}}

%% Шрифты
\usepackage{euscript}               % Шрифт Евклид
\usepackage{mathrsfs}               % \mathscr{}

%% Графика
\usepackage[pdftex]{graphicx}       % Вставка картинок
\graphicspath{{images/}}            % Стандартный путь к картинкам
\usepackage{tikz}                   % Рисование всего
\usepackage{pgfplots}               % Графики
\usetikzlibrary{calc,matrix}

%% Прочие пакеты
\usepackage{indentfirst}                    % Красная строка в начале текста
\usepackage{epigraph}                       % Эпиграфы
\usepackage{fancybox,fancyhdr}              % Колонтитулы
\usepackage[colorlinks=true, urlcolor=blue]{hyperref}   % Ссылки
\usepackage{titlesec}                       % Изменение формата заголовков
\usepackage[normalem]{ulem}                 % Для зачёркиваний
\usepackage[makeroom]{cancel}               % И снова зачёркивание (на этот раз косое)

%% Прочее
\mathtoolsset{showonlyrefs=true}        % Показывать номера только у тех формул,
% на которые есть \eqref{} в тексте.
\renewcommand{\headrulewidth}{1.8pt}    % Изменяем размер верхнего отступа колонтитула
\renewcommand{\footrulewidth}{0.0pt}    % Изменяем размер нижнего отступа колонтитула

%Прочее
\usepackage{forest} % Деревья

\renewcommand{\Re}{\mathrm{Re\:}}
\renewcommand{\Im}{\mathrm{Im\:}}
\newcommand{\Arg}{\mathrm{Arg\:}}
\renewcommand{\arg}{\mathrm{arg\:}}
\newcommand{\Mat}{\mathrm{Mat}}
\newcommand{\M}{\mathrm{M}}
\newcommand{\id}{\mathrm{id}}
\newcommand{\isom}{\xrightarrow{\sim}} 
\newcommand{\leftisom}{\xleftarrow{\sim}}
\newcommand{\Hom}{\mathrm{Hom}}
\newcommand{\Ker}{\mathrm{Ker}\:}
\newcommand{\rk}{\mathrm{rk}\:}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\ort}{\mathrm{ort}}
\newcommand{\pr}{\mathrm{pr}}
\newcommand{\vol}{\mathrm{vol\:}}
\newcommand{\Tr}{\mathrm{tr\:}}
\newcommand{\sgn}{\mathrm{sgn\:}}
\newcommand{\al}{\alpha}

%% Определения
\newtheorem{definition}{Определение}
\newtheorem*{defin}{Определение}
\newtheorem{Def}{Определение}
\newtheorem*{Lemma}{Лемма}
\newtheorem{Suggestion}{Предложение}
\newtheorem*{Examples}{Пример}
\newtheorem*{Consequence}{Следствие}
\newtheorem{Theorem}{Теорема}
\newtheorem*{ther}{Теорема}
\newtheorem{Statement}{Утверждение}
\newtheorem*{Task}{Упражнение}
\newtheorem*{Designation}{Обозначение}
\newtheorem*{Generalization}{Обобщение}
\newtheorem*{Thedream}{Предел мечтаний}
\newtheorem*{Properties}{Свойства}
\newtheorem*{Note}{Замечание}

\newtheorem*{Induction_def} {Принцип математической индукции}
\newtheorem*{Full_induction_def} {Принцип полной математической индукции}
\newtheorem*{Evc} {Алгорим Евклида}
\newtheorem*{state}{Утверждение}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\renewcommand{\C}{\mathbb{C}}
\renewcommand{\L}{\mathscr{L}}
\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\phi}{\varphi}
\newcommand{\e}{\mathbb{e}}
\renewcommand{\l}{\lambda}
\newcommand{\E}{\mathbb{E}}
\def\eps{\varepsilon}
\def\limref#1#2{{#1}\negmedspace\mid_{#2}}
\newcommand{\vvector}[1]{\begin{pmatrix}{#1}_1 \\\vdots\\{#1}_n\end{pmatrix}}
\renewcommand{\vector}[1]{({#1}_1, \ldots, {#1}_n)}

\definecolor{Gray}{gray}{0.9}
\newcolumntype{g}{>{\columncolor{Gray}}c}

\newtheorem*{canonther}{Теорема о приведении матрицы к каноническому виду}
\newtheorem*{lem}{Лемма}
\newtheorem*{lem1}{Лемма 1}
\newtheorem*{lem2}{Лемма 2}
\newtheorem*{lem3}{Лемма 3}

\newcommand{\p}{^{\prime}}

\begin{document}
	\title{Материалы для подготовки к коллоквиуму\\ по дискретной математике \\ Теоремы}
	\author{ПМИ 2016 \\ Орлов Никита, Рубачев Иван, Ткачев Андрей, Евсеев Борис}
	\maketitle
	
	\section*{}

	
	\begin{center}
		\line(1,0){450}
	\end{center}

	\section{1}

	\begin{Induction_def}
		Если для утверждения зависящего от положительного натурального $n$ выполняются следущие условия:
		\begin{itemize}
			\item 1. Утверждение истинно при $n = 1$
			\item 2. Когда утверждение истинно при $n = k$, оно истинно и при $n = k + 1$
		\end{itemize}
		Тогда утверждение истинно при всех положительных $n$.
	\end{Induction_def}

	\begin{Full_induction_def}
		Если для утверждения зависящего от положительного натурального $n$ выполняются следущие условия:
		\begin{itemize}
			\item 1. Утверждение истинно для $n = 1$
			\item 2. Если утверждение истинно для всех $n \leqslant k$, оно также истинно и для $n = k + 1$
		\end{itemize}
		Тогда утверждение истинно при всех положительных $n$.
	\end{Full_induction_def}
	\begin{state} Если уместна математическая индукция, то уместна и сильная индукция.
	\end{state}
	\begin{proof}
		В дальньейших рассуждениях будем считать, что $n$ - натуральное, большее или равное $1$, а также обозначим утверждение зависящее от $n$ за $\phi(n)$.

		Предположим, что для $\phi(n)$ выполняются условия $(1)$ и $(2)$ для сильной индукции.

		Пусть $\psi(k) \Leftrightarrow $ <<$\phi(n)$ истинно для всех $n \leqslant k$>>.

		Попытаемся доказать, что утверждение $\psi(n)$ истинно для всех положительных натуральных $n$ по индукции. Как следствие, мы получим, что и $\phi(n)$ верно для всех положительных $n$, т.е. тот же вывод, который должен дать принцип сильной индукции.

		\textit{База}. В силу нашего предположения $\phi(1)$ истинно (гипотеза $(1)$ сильной индукции верна), но тогда истинно и $\psi(1)$, по опеределению $\psi(n)$.

		\textit{Предположение}. Пусть верно $\psi(k)$.

		\textit{Шаг}. Мы предположили, что для $\phi(n)$ выполняются гипотезы сильной индукции, а значит, если <<$\phi(n)$ верно для всех $n \leqslant k$>>, то и $\phi(k + 1)$ - верно. По предположению индукции - $\psi(k) \Rightarrow \phi(k + 1)$ (см. определение $\psi(n)$ и гипотезу $(2)$ сильной индукции). Получаем, что $\psi(k + 1)$ - истинно, т.к. $\phi(n)$ истинно для всех $n \leqslant k + 1$ $\Rightarrow$ $\psi(k + 1)$.

		Согласно принципу мат. индукции $\psi(k)$ - верно для всех положительных $k$, занчит утверждение <<$\phi(n)$ истинно для всех $n \leqslant k$>> верно при всех $k$, а значит $\phi(n)$ - верно для всех $n$.

		Таким образом, из принципа мат. индукции следует принцип полной мат. индукциию.  
 	\end{proof}

 	\section*{5}
 	\begin{defin} [Формула включений и исключений.] Формула включений-исключений — комбинаторная формула, позволяющая определить мощность объединения конечного числа конечных множеств, которые в общем случае могут пересекаться друг с другом.
 	\end{defin}
 	\begin{state}
 	Пусть $ A_{1}, A_{2},\ldots , A_{n} $ — конечные множества. Формула включений-исключений утверждает:
 	$$\biggl | \bigcup_{i=1}^{n}A_i \biggl | = \sum_{i} | A_i | - \sum_{i<j} | A_i \cap A_j | + \sum_{i<j<k} | A_i \cap A_j \cap A_k | - \ldots + (-1)^{n-1} | A_1 \cap A_2 \cap \ldots \cap A_n |.$$
 	\end{state}

 	\begin{proof}
 	Рассмотрим произвольный элемент $x \in \biggl | \bigcup_{i=1}^{n}A_i \biggl |$, входящий в ровно $S$ множеств $A_{q_1}, ... A_{q_S}$ и подсчитаем, сколько раз он учитывается в правой части формулы включений-исключений (вернее покажем, что учитывается ровно 1 раз):
 		\begin{itemize}
 			\item В первой сумме $\sum_{i} | A_i |$ элемент  $x$ посчитан ровно ${S \choose 1} = S$ раз (В слагаемых $A_{q_1}, ... A_{q_S}$).

 			\item Во второй сумме $\sum_{i<j} | A_i \cap A_j |$ элемент $x$ посчитан ровно ${S \choose 2}$ раз (количесво попарных пересечений $A_i \cap A_j$, таких, что $A_i, A_j \in A_{q_1}, ... A_{q_S}$).

 			\item В третьей сумме $\sum_{i<j<k} | A_i \cap A_j \cap A_k |$ $x$ будет посчитан ${S \choose 3}$ раза (количество пересечений $A_i \cap A_j \cap A_k$ для которых $i, j \in q_1, \ldots q_S$).

 			...

 			\item В $S$-ой сумме $\sum_{i_1<i_2<\ldots<i_S} | A_{i_1} \cap A_{i_2} \cap \ldots \cap A_{i_S} |$
 			$x$ будет посчитан ${S \choose S} = 1$  раз ($x$ войдет только в слагаемое $| A_1 \cap A_2 \cap \ldots \cap A_n |$).

 			\item суммы, содержащие $S + 1$ и более пересечений, не учитывают элемент $x$, поскольку $x$ не входит в пересечение более чем $S$ множеств.
 		\end{itemize}

 		Таким образом $x$ оказывается посчитанным ровно $S - {S \choose 2} + {S \choose 3} - \ldots + (-1)^{S + 1} {S \choose S}$ раз. Покажем, что эта сумма в точности равна 1. Воспользуемся биномом Ньютона:

 		$$0 = (1 - 1)^S =
 		\sum_{k = 0}^{S} {S \choose k} \cdot 1^{S - k} \cdot (-1)^{k} =
 		1 - \sum_{k = 1}^{S} {S \choose k} \cdot 1^{S - k} \cdot (-1)^{k + 1}$$

 		$$\Updownarrow$$
 		$$1 = \sum_{k = 1}^{S} {S \choose k} \cdot (-1)^{k + 1} =
 		S - {S \choose 2} + {S \choose 3} - \ldots + (-1)^{S + 1} {S \choose S}$$

 		Таким образом, каждый $x \in \biggl | \bigcup_{i=1}^{n}A_i \biggl |$ учитывается и левой и правой частью формулы ровно 1 раз, и очевидно, что все прочие $y \notin \biggl | \bigcup_{i=1}^{n}A_i \biggl |$ не учитываются ни правой, ни левой частями.
 	\end{proof}

 	\section*{13}
 	\begin{defin} \textbf{Частичный граф} исходного графа $G = (V, E)$ — граф $G^{\prime} = (V, E^{\prime})$, $E^{\prime} \subseteq E$.
	\end{defin}

	\begin{defin} \textbf{Остовное дерево} связного графа $G = (V, E)$ — всякий его частичный граф, являющийся деревом.
	\end{defin}

	\begin{Lemma} Если граф связен, то у него есть остовное дерево. 
	\end{Lemma}

	\begin{proof}
	Для начала докажем вспомогательную лемму:
		\begin{Lemma} Если граф связен и содержит хотябы один цикл, то из него можно удалить ребро не нарушая связности. 
		\end{Lemma}

		\begin{proof}[Доказательство леммы]
		Пусть $ G = (V, E) $ и цикл в нем: $ u_0 \rightarrow u_1 \rightarrow ... u_n \rightarrow u_0,\ u_i \in V$. Поймем, что если удалить любое ребро принадлежащее цикул, связность не нарушится. Покажем в частности, что можно удалит ребро $(u_0, u_1)$. Действительно, если есть какой-нибудь путь из $v  \in V$ в $w \in V$, проходящий через ребро $ (u_0,\ u_1) $, то существует путь проходящий через прочие ребра цикла, ведь в цикле до каждой вершины можно дойти хотя бы двумя разными путями, значит удаление ребра не изменит того факта, что $v$ соединено путем с $w$. Если пути из $v$ к $w$ не содержат ребра $(u_0, u_1)$, то очевидно, что его удаление на их связи не отразится $\Rightarrow$ граф без этого ребра останется связанным. Тогда удалим его и получим связный граф.
		\end{proof}

		Пусть тепереь $G = (V,\ E)$ - связный граф, для которого нужно доказать существование остовног дерева. Возможны два сценария:
			\begin{enumerate} 
			\item Граф $G$ - связный граф без циклов.
			\item В графе $G$ есть хотя бы один цикл. 
			\end{enumerate}

		В первом случае $G$ - дерево по определению, а значит сам является своим остовным деревом.

		Во втором случае, по доказанной лемме, мы можем удалить из $G$ ребро не нарушая связности. Так сделаем же это. Если полученный граф - цикличен, то снова удалим ребро не нарушая связности, иначе остановимся и порадуемся; индуктивно будем повторять описанные операции, на каждой иттерации имея связный граф; число ребер в графе - конечно, значит процесс не может продолжаться вечно $\Rightarrow$ в какой-то момент мы не сможем удалить ребро не нарушая связности, что было бы не возможно, если бы в графе остался цикл. В ходе описанных операций мы не добавляли новых ребер и не удаляли вершин $\Rightarrow$ если  $G^{\prime} = (V^{\prime},\ E^{\prime})$ - итоговый граф, то $V^{\prime} = V$, $E^{\prime} \subseteq E$ $\Rightarrow$ $G^{\prime}$ - частичный граф графа $G$, связный и без цилов, т.е. дерево $\Rightarrow$ $G^{\prime}$ по определению - остовное дерево графа $G$.
	\end{proof}

	\section*{17}
		\begin{Note} Здесь и далее условимся обозначать НОД$(a, N)$, как $(a,\ N)$.
		\end{Note}
		\begin{state}
		Сравнение $ax \equiv 1\ (mod N)$ имеет решение $(1)$ $\Leftrightarrow$ $(a, N) = 1$ $(2)$. 
		\end{state}
		\begin{proof}
		Докажем следствие $(1) \Rightarrow (2)$
		$$ax - 1\equiv 0\ (mod\ N)$$ 
		$$\Downarrow$$ 
		$$N | (ax - 1)$$
		$$\Downarrow$$ 
		$$(ax - 1) = Nk,\ k \in Z.$$

		Пусть $(a,\ N) = b$ ($1 \leqslant b$, т.к. 1 - всегда делитель).
		Тогда $a = a\p \cdot b$, $N = N\p \cdot b$ $\Rightarrow$
		$$a\p bx - 1 = N\p bk$$
		$$\Downarrow$$
		$$1 = b(a\p x - N\p k)$$

		По определению $b|1$, но тогда $|b| \leqslant 1$, но тогда $b = 1$ $\Rightarrow$$(a,\ N) = 1$.

		Докажем следствие $(2) \Rightarrow (1)$: $(2) \Rightarrow (a,\ N) = 1$, тогда по соотношению Безу $\exists m,\ k:\ am + Nk = 1 \Rightarrow am = 1 - Nk \Rightarrow$ $am \equiv 1\ (mod\ N)$, и $x=m$ - решение сравния $ax \equiv 1\ (mod\ N)$.  
		\end{proof}

		\section*{21}
		\begin{Evc}
		Пусть $a$ и $b$ - целые числа одноверемненно не равные нулю, и последовательность чисел
		$ x_0 > x_1 > x_2 > x_3 \cdots > x_n > 0$
		определена тем, что $x_0 = a,\ x_1 = b$, каждое $x_k,\ k > 1$ — это остаток от деления предпредыдущего числа на предыдущее, а предпоследнее делится на последнее нацело, то есть:
		$$a = x_0q_1 + x_1,$$
		$$b = x_1q_2 + x_2,$$
		$$x_2 = x_3q_3 + x_4,$$
		$$\cdots$$
		$$x_{k-2} = x_{k-1} q_{k-1} + x_k,$$	 
		$$\cdots$$
		$$x_{n-2} = x_{n-1}q_{n-1}+ x_n,$$
		$$x_{n-1} = x_n q_n.$$
		Тогда $(a, b)$ равен $x_n$, последнему ненулевому члену этой последовательности.
		\end{Evc}
		\begin{proof}
			Поймем, что такие $r_1, r_2, r_3, r_4, \cdots r_n$ - существуют, причем единственно: всегда можно найти остаток $m$ (причем единственным образом) при делении $r_k$ на $r_{k + 1}$, если $r_{k + 1} \ne 0$, причем $a > b > r_k > r_{k + 1} > m$, т.е. каждый следующий член последовательности строго меньше предыдущего, но т.к. числа ее составляющие - целые, то убывать бесконечно она не может, а значит $\exists x_{n + 1} = 0$ - последний член последовательности.

			Докажем тогда, что если $x_n$ - последний не нулевой член последовательности, то $(a, b) = (x_n, 0) = x_n \ne 0$. Для этого заметим две вещи:
			\begin{enumerate}
				\item $r \ne 0 \Rightarrow (r, 0) = |r|$ так как 0 делится на любое целое число, кроме нуля.

				\item Пусть $a = bq + r$, тогда $(a,\ b) = (b,\ r)$.
				Пусть $k$ — любой общий делитель чисел $a$ и $b$, не обязательно наибольший, тогда $a = t_1k$ и $b = t_2k$, где $t_1$ и $t_2$ — целые числа из определения.

				Тогда $k$ является также общим делителем чисел $b$ и $r$, так как $b$ делится на $k$ по определению, а $r = a - b\cdot q = (t_1 - t_2\cdot q)\cdot k$ (выражение в скобках есть целое число, следовательно, $k$ делит $r$ без остатка). 
				
				Обратное также верно. Любой делитель $k$ чисел $b$ и $r$ так же является делителем $a$ и $b$: $a = b \cdot q + r = k\cdot (b\p q + r\p)$$\Rightarrow$ $k|a$.
				
				Следовательно, все общие делители пар чисел $a$, $b$ и $b$, $r$совпадают. Другими словами, нет общего делителя у чисел $a$, $b$, который не был бы также делителем $b$, $r$, и наоборот.
				
				В частности, наибольший общий делитель остается тем же самым. Что и требовалось доказать.
			\end{enumerate}

			Тогда по построению последовательности $\{x_i\}: (x_0,\ x_1) = (x_1,\ x_2) = (x_2,\ x_3) = \ldots = (x_n,\ 0) = x_n$.
		\end{proof}
		\begin{Evc}[Расширенный алгоритм Евклида] 
			Формулы для $x_i$ могут быть переписаны следующим образом:
			$x_0 = aq_0 + bp_0$,
			$x_1 = aq_1 + bp_1$,
			$x_2 = aq_2 + bp_2$
			$x_3 = aq_3 + bp_3$
	 		$\vdots$
			$(a,\ b) = x_n = as + bt$
		\end{Evc}
		\begin{proof}
			Докажем по индукции по $n$. 

			\textit{База.} $x_0 = a + b \cdot 0$, $x_1 = a \cdot 0 + b$. Т.е. $q_0 = P_1 = 1,\ p_0 = q_1 = 0$

			\textit{Предположение.} Пусть $x_{k - 2} = aq_{k - 2} + bp_{k - 2}$ и $x_{k - 1} = aq_{k - 1} + bp_{k - 1}$.

			\textit{Шаг.} Докажем, что $x_k = aq_{k} + bp_{k}$, где $q_k,\ p_k$ - целые. Мы помним, что $x_k$ - остаток от деления $x_{k - 2}$ на $x_{k - 1}$, значит по определнию: $m\cdot x_{k - 1} + x_k = x_{k - 2}$, где $m$ - какое-то целое число. Тогда $x_k = x_{k - 2} - m \cdot x_{k - 1}$, по п.и., $x_k = aq_{k - 2} + bp_{k - 2} - m(aq_{k - 1} + bp_{k - 1}) = a(q_{k - 2} - mq_{k - 1}) + b(p_{k - 2} - mp_{k - 1}) = aq_{k} + bp_{k}$.

			Таким образом каждое из чисел $x_i$ представимо в виде линейной комбинации $a$ и $b$ (В частности, если $(a,\ b) = 1$, то $\exists x,\ y: ax + by = 1$).
		\end{proof}
\end{document}
