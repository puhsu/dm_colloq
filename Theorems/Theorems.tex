\documentclass[a4paper,12pt]{article}

%% Начало шапки

%% Настройка поддержки русского языка
\usepackage{cmap}                   % Поиск по кириллице
\usepackage{mathtext}               % Кириллица в формулах
\usepackage[T1,T2A]{fontenc}        % Кодировки шрифтов
\usepackage[utf8]{inputenc}         % Кодировка текста
\usepackage[english,russian]{babel} % Подключение поддержки языков

%% Настройка размеров полей
\usepackage[top=0.7in, bottom=0.75in, left=0.625in, right=0.625in]{geometry}

%% Математические пакеты
\usepackage{mathtools}              % Тот же amsmath, только с некоторыми поправками
\usepackage{amssymb}                % Математические символы
\usepackage{amsthm}                 % Оформление теорем
\usepackage{amstext}                % Текстовые вставки в формулы
\usepackage{amsfonts}               % Математические шрифты
\usepackage{icomma}                 % "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление
\usepackage{enumitem}               % Для выравнивания itemize (\begin{itemize}[align=left])
\usepackage{array}                  % Таблицы и матрицы
\usepackage{multirow}

%% Алгоритмические пакеты и их настройки
\usepackage{algorithm}              % Шапка алгоритма
\usepackage{algorithmicx}           % Написание алгоритмов
\usepackage[noend]{algpseudocode}   % Написание псевдокода; убраны end
\usepackage{listings}               % Для кода на каком-либо языке программиования
\renewcommand{\algorithmicrequire}{\textbf{Ввод:}}              % Ввод
\renewcommand{\algorithmicensure}{\textbf{Вывод:}}              % Вывод
\floatname{algorithm}{Алгоритм}                                 % Название алгоритма
\renewcommand{\algorithmiccomment}[1]{\hspace*{\fill}\{// #1\}} % Комментарии
\newcommand{\algname}[1]{\textsc{#1}}                           % Вызов функции в алгоритме

\newcommand*{\hm}[1]{#1\nobreak\discretionary{}
	{\hbox{$\mathsurround=0pt #1$}}{}}

%% Шрифты
\usepackage{euscript}               % Шрифт Евклид
\usepackage{mathrsfs}               % \mathscr{}

%% Графика
\usepackage[pdftex]{graphicx}       % Вставка картинок
\graphicspath{{images/}}            % Стандартный путь к картинкам
\usepackage{tikz}                   % Рисование всего
\usepackage{pgfplots}               % Графики
\usetikzlibrary{calc,matrix}

%% Прочие пакеты
\usepackage{indentfirst}                    % Красная строка в начале текста
\usepackage{epigraph}                       % Эпиграфы
\usepackage{fancybox,fancyhdr}              % Колонтитулы
\usepackage[colorlinks=true, urlcolor=blue]{hyperref}   % Ссылки
\usepackage{titlesec}                       % Изменение формата заголовков
\usepackage[normalem]{ulem}                 % Для зачёркиваний
\usepackage[makeroom]{cancel}               % И снова зачёркивание (на этот раз косое)

%% Прочее
\mathtoolsset{showonlyrefs=true}        % Показывать номера только у тех формул,
% на которые есть \eqref{} в тексте.
\renewcommand{\headrulewidth}{1.8pt}    % Изменяем размер верхнего отступа колонтитула
\renewcommand{\footrulewidth}{0.0pt}    % Изменяем размер нижнего отступа колонтитула

%Прочее
\usepackage{forest} % Деревья

\renewcommand{\Re}{\mathrm{Re\:}}
\renewcommand{\Im}{\mathrm{Im\:}}
\newcommand{\Arg}{\mathrm{Arg\:}}
\renewcommand{\arg}{\mathrm{arg\:}}
\newcommand{\Mat}{\mathrm{Mat}}
\newcommand{\M}{\mathrm{M}}
\newcommand{\id}{\mathrm{id}}
\newcommand{\isom}{\xrightarrow{\sim}} 
\newcommand{\leftisom}{\xleftarrow{\sim}}
\newcommand{\Hom}{\mathrm{Hom}}
\newcommand{\Ker}{\mathrm{Ker}\:}
\newcommand{\rk}{\mathrm{rk}\:}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\ort}{\mathrm{ort}}
\newcommand{\pr}{\mathrm{pr}}
\newcommand{\vol}{\mathrm{vol\:}}
\newcommand{\Tr}{\mathrm{tr\:}}
\newcommand{\sgn}{\mathrm{sgn\:}}
\newcommand{\al}{\alpha}

%% Определения
\newtheorem{definition}{Определение}
\newtheorem*{defin}{Определение}
\newtheorem{Def}{Определение}
\newtheorem*{Lemma}{Лемма}
\newtheorem{Suggestion}{Предложение}
\newtheorem*{Examples}{Пример}
\newtheorem*{Consequence}{Следствие}
\newtheorem{Theorem}{Теорема}
\newtheorem{Statement}{Утверждение}
\newtheorem*{Task}{Упражнение}
\newtheorem*{Designation}{Обозначение}
\newtheorem*{Generalization}{Обобщение}
\newtheorem*{Thedream}{Предел мечтаний}
\newtheorem*{Properties}{Свойства}
\newtheorem*{Note}{Замечание}

\newtheorem*{Induction_def} {Принцип математической индукции}
\newtheorem*{Full_induction_def} {Принцип полной математической индукции}
\newtheorem*{Evc} {Алгорим Евклида}
\newtheorem*{state}{Утверждение}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\renewcommand{\C}{\mathbb{C}}
\renewcommand{\L}{\mathscr{L}}
\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\phi}{\varphi}
\newcommand{\e}{\mathbb{e}}
\renewcommand{\l}{\lambda}
\newcommand{\E}{\mathbb{E}}
\def\eps{\varepsilon}
\def\limref#1#2{{#1}\negmedspace\mid_{#2}}
\newcommand{\vvector}[1]{\begin{pmatrix}{#1}_1 \\\vdots\\{#1}_n\end{pmatrix}}
\renewcommand{\vector}[1]{({#1}_1, \ldots, {#1}_n)}

\definecolor{Gray}{gray}{0.9}
\newcolumntype{g}{>{\columncolor{Gray}}c}

\newtheorem*{canonther}{Теорема о приведении матрицы к каноническому виду}
\newtheorem*{lem}{Лемма}
\newtheorem*{lem1}{Лемма 1}
\newtheorem*{lem2}{Лемма 2}
\newtheorem*{lem3}{Лемма 3}

\newcommand{\p}{^{\prime}}

\begin{document}
	\title{Материалы для подготовки к коллоквиуму\\ по дискретной математике \\
	Теоремы}
	\author{ПМИ 2016 \\ Орлов Никита, Рубачев Иван, Ткачев Андрей, Евсеев Борис}
	\maketitle
	
	\section*{}

	
	\begin{center}
		\line(1,0){450}
	\end{center}

	\section{1. Вывод принципа полной математической индукции из принципа математической индукции}

	\begin{Induction_def}
		Если для утверждения зависящего от положительного натурального $n$ выполняются следущие условия:
		\begin{itemize}
			\item 1. Утверждение истинно при $n = 1$
			\item 2. Когда утверждение истинно при $n = k$, оно истинно и при $n = k + 1$
		\end{itemize}
		Тогда утверждение истинно при всех положительных $n$.
	\end{Induction_def}

	\begin{Full_induction_def}
		Если для утверждения зависящего от положительного натурального $n$ выполняются следущие условия:
		\begin{itemize}
			\item 1. Утверждение истинно для $n = 1$
			\item 2. Если утверждение истинно для всех $n \leqslant k$, оно также истинно и для $n = k + 1$
		\end{itemize}
		Тогда утверждение истинно при всех положительных $n$.
	\end{Full_induction_def}
	\begin{state} 
		Если уместна математическая индукция, то уместна и сильная индукция.
	\end{state}
	\begin{proof}
		В дальньейших рассуждениях будем считать, что $n$ - натуральное, большее или равное $1$, а также обозначим утверждение зависящее от $n$ за $\phi(n)$.

		Предположим, что для $\phi(n)$ выполняются условия $(1)$ и $(2)$ для сильной индукции.

		Пусть $\psi(k) \Leftrightarrow $ <<$\phi(n)$ истинно для всех $n \leqslant k$>>.

		Попытаемся доказать, что утверждение $\psi(n)$ истинно для всех положительных натуральных $n$ по индукции. Как следствие, мы получим, что и $\phi(n)$ верно для всех положительных $n$, т.е. тот же вывод, который должен дать принцип сильной индукции.

		\textit{База}. В силу нашего предположения $\phi(1)$ истинно (гипотеза $(1)$ сильной индукции верна), но тогда истинно и $\psi(1)$, по опеределению $\psi(n)$.

		\textit{Предположение}. Пусть верно $\psi(k)$.

		\textit{Шаг}. Мы предположили, что для $\phi(n)$ выполняются гипотезы сильной индукции, а значит, если <<$\phi(n)$ верно для всех $n \leqslant k$>>, то и $\phi(k + 1)$ - верно. По предположению индукции - $\psi(k) \Rightarrow \phi(k + 1)$ (см. определение $\psi(n)$ и гипотезу $(2)$ сильной индукции). Получаем, что $\psi(k + 1)$ - истинно, т.к. $\phi(n)$ истинно для всех $n \leqslant k + 1$ $\Rightarrow$ $\psi(k + 1)$.

		Согласно принципу мат. индукции $\psi(k)$ - верно для всех положительных $k$, занчит утверждение <<$\phi(n)$ истинно для всех $n \leqslant k$>> верно при всех $k$, а значит $\phi(n)$ - верно для всех $n$.

		Таким образом, из принципа мат. индукции следует принцип полной мат. индукциию.  
 	\end{proof}

 	\section*{2. Бином Ньютона. Формула для биномиальных коэффициентов}
    Число сочетаний из $n$ по $k$ равно:
    \[
        \binom{n}{k} = \frac{n!}{k!(n - k)!}
    \]
    \begin{proof}
        На первое место можно поставить любой из $n$ элементов, на второе любой из $n - 1$ оставшихся, $\ldots$, на $k$-е любой из $n - k + 1$. Тогда по правилу произведения существует $n(n - 1)(n - 2)\cdots(n - k + 1)$ упорядоченных наборов. Но порядок нам не важен, поэтому существует $\displaystyle\frac{n(n - 1)(n - 2)\cdots(n - k + 1)}{k!} = \frac{n!}{k!(n - k)!}$ неупорядоченных наборов.
    \end{proof}
    Формула бинома Ньютона имеет вид:
    \[
        (a + b)^{n} = \binom{n}{0}a^{n} + \binom{n}{1}a^{n - 1}b + \ldots + \binom{n}{k}a^{n - k}b^{k} + \ldots + \binom{n}{n}b^{n} = \sum_{k = 0}^{n}\binom{n}{k}a^{n - k}b^{k}
    \]
    \begin{proof}
        Раскрытие скобок даст все возможные комбинации $a$ и $b$ длины $n$. Так как умножение коммутативно, то элементы с одинаковым количеством $b$ можно сгрупировать. Тогда перед $a^{n - k}b^{k}$ будет стоять коэффициент $c$. Количество слогаемых, в которых $b$ встречается ровно $k$ раз равно $\displaystyle\binom{n}{k}$. Тогда $c = \displaystyle\binom{n}{k}$, а значит:
        \[
            (a + b)^{n} = \sum_{k = 0}^{n}\binom{n}{k}a^{n - k}b^{k}
        \]
    \end{proof}
    \pagebreak % временно

 	\section*{5. Доказательство формулы включений и исключений}
 	\begin{defin} [Формула включений и исключений.] Формула включений-исключений — комбинаторная формула, позволяющая определить мощность объединения конечного числа конечных множеств, которые в общем случае могут пересекаться друг с другом.
 	\end{defin}
 	\begin{state}
		Пусть $ A_{1}, A_{2},\ldots , A_{n} $ — конечные множества. Формула включений-исключений утверждает:
		$$\biggl | \bigcup_{i=1}^{n}A_i \biggl | =
		 \sum_{i} | A_i | - \sum_{i<j} | A_i \cap A_j | + \sum_{i<j<k} | A_i \cap A_j \cap A_k | - \ldots + (-1)^{n-1} | A_1 \cap A_2 \cap \ldots \cap A_n |.$$
 	\end{state}

 	\begin{proof}
	 	Рассмотрим произвольный элемент $x \in \biggl | \bigcup_{i=1}^{n}A_i \biggl |$, входящий в ровно $S$ множеств $A_{q_1}, ... A_{q_S}$ и подсчитаем, сколько раз он учитывается в правой части формулы включений-исключений (вернее покажем, что учитывается ровно 1 раз):
	 		\begin{itemize}
	 			\item В первой сумме $\sum_{i} | A_i |$ элемент  $x$ посчитан ровно ${S \choose 1} = S$ раз (В слагаемых $A_{q_1}, ... A_{q_S}$).

	 			\item Во второй сумме $\sum_{i<j} | A_i \cap A_j |$ элемент $x$ посчитан ровно ${S \choose 2}$ раз (количесво попарных пересечений $A_i \cap A_j$, таких, что $A_i, A_j \in A_{q_1}, ... A_{q_S}$).

	 			\item В третьей сумме $\sum_{i<j<k} | A_i \cap A_j \cap A_k |$ $x$ будет посчитан ${S \choose 3}$ раза (количество пересечений $A_i \cap A_j \cap A_k$ для которых $i, j \in q_1, \ldots q_S$).

	 			...

	 			\item В $S$-ой сумме $\sum_{i_1<i_2<\ldots<i_S} | A_{i_1} \cap A_{i_2} \cap \ldots \cap A_{i_S} |$
	 			$x$ будет посчитан ${S \choose S} = 1$  раз ($x$ войдет только в слагаемое $| A_1 \cap A_2 \cap \ldots \cap A_n |$).

	 			\item суммы, содержащие $S + 1$ и более пересечений, не учитывают элемент $x$, поскольку $x$ не входит в пересечение более чем $S$ множеств.
	 		\end{itemize}

	 		Таким образом $x$ оказывается посчитанным ровно $S - {S \choose 2} + {S \choose 3} - \ldots + (-1)^{S + 1} {S \choose S}$ раз. Покажем, что эта сумма в точности равна 1. Воспользуемся биномом Ньютона:

	 		$$0 = (1 - 1)^S =
	 		\sum_{k = 0}^{S} {S \choose k} \cdot 1^{S - k} \cdot (-1)^{k} =
	 		1 - \sum_{k = 1}^{S} {S \choose k} \cdot 1^{S - k} \cdot (-1)^{k + 1}$$

	 		$$\Updownarrow$$
	 		$$1 = \sum_{k = 1}^{S} {S \choose k} \cdot (-1)^{k + 1} =
	 		S - {S \choose 2} + {S \choose 3} - \ldots + (-1)^{S + 1} {S \choose S}$$

	 		Таким образом, каждый $x \in \biggl | \bigcup_{i=1}^{n}A_i \biggl |$ учитывается и левой и правой частью формулы ровно 1 раз, и очевидно, что все прочие $y \notin \biggl | \bigcup_{i=1}^{n}A_i \biggl |$ не учитываются ни правой, ни левой частями.
 	\end{proof}


    \section*{6. Формулы для суммы степеней вершин в неориентированном и в ориентированном графе}

    \begin{defin}
        Сумма степеней всех вершин в неориентированном графе равна удвоенному числу ребер. $\displaystyle\sum_{v \in V(G)} \deg(v) = 2 \cdot |E(G)|$
    \end{defin}
    \begin{proof}
        Пусть в графе степень каждой вершины равна $0$ (в графе нет ребер). При добавлении ребра, связывающего любые две вершины, сумма всех степеней увеличивается на 2 единицы. Таким образом, сумма всех степеней вершин четна и равна удвоенному числу ребер.
    \end{proof}
    \begin{defin}
        Число исходящих степеней вершин равно числу входящих, равно числу ребер.
    \end{defin}
    \begin{proof}
        Первая часть утверждения очевидна. Каждое ребро выходит из одной вершины и входит в другую, поэтому каждое ребро дает одинаковый вклад в суммы исходящих и входящих степеней вершин. Для доказательства второй части утверждения докажем что число ребер равно числу исходящих степеней вершин. Исходящая степень вершины равна числу ребер, которые из нее выходят. Ребро не может выходить более чем из одной вершины, поэтому сумма исходящих степеней вершин равна числу ребер. По транзитивности отношения <<=>> число ребер равно также и сумме исходящих вершин.
    \end{proof}
    \section*{10. Деревья -- это в точности минимально связные графы}
    \begin{proof}\ \\
        $[\Rightarrow]$ Докажем индукцией по числу вершин. База: для $n = 2$ существует лишь одно дерево, для которого утверждение очевидно. Предположим это для некоторого дерева $G_{n}$ на $n$ вершинах, в котором $n - 1$ ребро. Шаг для $n + 1$: добавляя одну вершину $u$, нужно связать её с графом $G_{n}$, то есть соединить с некоторыми вершинами. Если бы мы соединили её с двумя вершинами $v_{1}$ и $v_{2}$, то у нас в графе $G_{n+1}$ получился бы цикл, так как в $G_{n}$ уже существовал путь $v_{1}, a_{1}, a_{2},\ldots, a_{k}, v_{2}$, а значит в $G_{n+1}$ существует цикл $v_{1}, a_{1}, a_{2},\ldots, a_{k}, v_{2}, u, v_{1}$, а значит $G_{n+1}$ -- не дерево. Значит, при добавлении вершины мы можем добавить не более одного ребра (а для сохранения связности ещё и более 0), значит $G_{n+1}$ должен содержать $n - 1 + 1 = n$ рёбер, что означает, что предположение индукции выполнено и для $n + 1$.
        
        \noindent$[\Leftarrow]$ Для начала докажем что в связном графе не может меньше чем $n - 1$ ребро по индукции. База: для $n = 2$ граф на 2-ух вершинах, все очевидно. Шаг для $n + 1$: если для $n$ вершин утверждение верно, то для $n + 1$ вершины оно тоже будет верно, так как нужно связать добавленную вершину как минимум с одним ребром (то есть ребер станет не менее чем $n - 1 + 1 = n$). Пусть у нас есть связный граф на $n$ вершинах, с $n - 1$ ребрами и в этом графе есть циклы. Из некоторого цикла удалим ребро соединявшее вершины $u$ и $v$, при этом граф останется связным, но в нем будет уже $n - 2$ ребра -- получили противоречие. Значит в таком минимально связном графе нет циклов, то есть этот граф -- дерево.
    \end{proof}
    \pagebreak % временно
 	\section*{13. Существование остовного дерева}
 	\begin{defin} \textbf{Частичный граф} исходного графа 
 		$G = (V, E)$ — граф $G^{\prime} = (V, E^{\prime})$, $E^{\prime} \subseteq E$.
	\end{defin}

	\begin{defin} \textbf{Остовное дерево} связного графа $G = (V, E)$ — всякий его частичный граф, являющийся деревом.
	\end{defin}

	\begin{Lemma} 
		Если граф связен, то у него есть остовное дерево. 
	\end{Lemma}

	\begin{proof}
	Для начала докажем вспомогательную лемму:
		\begin{Lemma} Если граф связен и содержит хотябы один цикл, то из него можно удалить ребро не нарушая связности. 
		\end{Lemma}

		\begin{proof}[Доказательство леммы]
		Пусть $ G = (V, E) $ и цикл в нем: $ u_0 \rightarrow u_1 \rightarrow ... u_n \rightarrow u_0,\ u_i \in V$. Поймем, что если удалить любое ребро принадлежащее цикул, связность не нарушится. Покажем в частности, что можно удалит ребро $(u_0, u_1)$. Действительно, если есть какой-нибудь путь из $v  \in V$ в $w \in V$, проходящий через ребро $ (u_0,\ u_1) $, то существует путь проходящий через прочие ребра цикла, ведь в цикле до каждой вершины можно дойти хотя бы двумя разными путями, значит удаление ребра не изменит того факта, что $v$ соединено путем с $w$. Если пути из $v$ к $w$ не содержат ребра $(u_0, u_1)$, то очевидно, что его удаление на их связи не отразится $\Rightarrow$ граф без этого ребра останется связанным. Тогда удалим его и получим связный граф.
		\end{proof}

		Пусть тепереь $G = (V,\ E)$ - связный граф, для которого нужно доказать существование остовног дерева. Возможны два сценария:
			\begin{enumerate} 
			\item Граф $G$ - связный граф без циклов.
			\item В графе $G$ есть хотя бы один цикл. 
			\end{enumerate}

		В первом случае $G$ - дерево по определению, а значит сам является своим остовным деревом.

		Во втором случае, по доказанной лемме, мы можем удалить из $G$ ребро не нарушая связности. Так сделаем же это. Если полученный граф - цикличен, то снова удалим ребро не нарушая связности, иначе остановимся и порадуемся; индуктивно будем повторять описанные операции, на каждой иттерации имея связный граф; число ребер в графе - конечно, значит процесс не может продолжаться вечно $\Rightarrow$ в какой-то момент мы не сможем удалить ребро не нарушая связности, что было бы не возможно, если бы в графе остался цикл. В ходе описанных операций мы не добавляли новых ребер и не удаляли вершин $\Rightarrow$ если  $G^{\prime} = (V^{\prime},\ E^{\prime})$ - итоговый граф, то $V^{\prime} = V$, $E^{\prime} \subseteq E$ $\Rightarrow$ $G^{\prime}$ - частичный граф графа $G$, связный и без цилов, т.е. дерево $\Rightarrow$ $G^{\prime}$ по определению - остовное дерево графа $G$.
	\end{proof}

	\section*{17. Сравнение $ax \equiv 1\ (mod\ N)$ имеет решение тогда и только тогда, когда $(a, N) = 1$}
		\begin{Note} Здесь и далее условимся обозначать НОД$(a, N)$, как $(a,\ N)$.
		\end{Note}
		\begin{state}
		Сравнение $ax \equiv 1\ (mod N)$ имеет решение $(1)$ $\Leftrightarrow$ $(a, N) = 1$ $(2)$. 
		\end{state}
		\begin{proof}
		Докажем следствие $(1) \Rightarrow (2)$
		$$ax - 1\equiv 0\ (mod\ N)$$ 
		$$\Downarrow$$ 
		$$N | (ax - 1)$$
		$$\Downarrow$$ 
		$$(ax - 1) = Nk,\ k \in Z.$$

		Пусть $(a,\ N) = b$ ($1 \leqslant b$, т.к. 1 - всегда делитель).
		Тогда $a = a\p \cdot b$, $N = N\p \cdot b$ $\Rightarrow$
		$$a\p bx - 1 = N\p bk$$
		$$\Downarrow$$
		$$1 = b(a\p x - N\p k)$$

		По определению $b|1$, но тогда $|b| \leqslant 1$, но тогда $b = 1$ $\Rightarrow$$(a,\ N) = 1$.

		Докажем следствие $(2) \Rightarrow (1)$: $(2) \Rightarrow (a,\ N) = 1$, тогда по соотношению Безу $\exists m,\ k:\ am + Nk = 1 \Rightarrow am = 1 - Nk \Rightarrow$ $am \equiv 1\ (mod\ N)$, и $x=m$ - решение сравния $ax \equiv 1\ (mod\ N)$.  
		\end{proof}

		\section*{18. Признаки делимости на 3, 9 и 11}

        Число $x$ делистся на $3$ (на $9$) тогда и только тогда, когда сумма его цифр делится на $3$ (на $9$)
        \begin{proof}
            Пусть $x = \overline{a_{n}a_{n - 1}\ldots a_{1}a_{0}} = 10^{n}a_{n} + 10^{n - 1}a_{n - 1} + \ldots + 10a_{1} + a_{0}$. Так как\\
            $10 \equiv 1 \pmod 3$, то:
            \[
                x \equiv \sum_{i = 0}^{n} a_{i} \pmod 3
            \]
            Для делимости на $9$ доказательство аналогично.
        \end{proof}
        Число $x$ делится на $11$, тогда и только тогда, когда:
        \[
        	11 | \bigg(\sum_{2 \mid i}^{n} a_{i} - \sum_{2 \nmid i}^{n} a_{i}\bigg)
        \]
        \begin{proof}
        	$10 \equiv -1 \pmod{11}$, значит $10^{n} \equiv (-1)^{n} \pmod{11}$. Тогда:
        	\[
        		x \equiv (-1)^{n}a_{n} + (-1)^{n - 1}a_{n - 1} + \ldots + (-1)a_{1} + a_{0} \equiv \sum_{2 \mid i}^{n} a_{i} - \sum_{2 \nmid i}^{n} a_{i} \pmod{11}
        	\]
        \end{proof}

		\section*{21. Корректность алгоритма Евклида и расширенного алгоритма Евклида.}
		\begin{Evc}
		Пусть $a$ и $b$ - целые числа одноверемненно не равные нулю, и последовательность чисел
		$ x_0 > x_1 > x_2 > x_3 \cdots > x_n > 0$
		определена тем, что $x_0 = a,\ x_1 = b$, каждое $x_k,\ k > 1$ — это остаток от деления предпредыдущего числа на предыдущее, а предпоследнее делится на последнее нацело, то есть:
		$$a = x_0q_1 + x_1,$$
		$$b = x_1q_2 + x_2,$$
		$$x_2 = x_3q_3 + x_4,$$
		$$\cdots$$
		$$x_{k-2} = x_{k-1} q_{k-1} + x_k,$$	 
		$$\cdots$$
		$$x_{n-2} = x_{n-1}q_{n-1}+ x_n,$$
		$$x_{n-1} = x_n q_n.$$
		Тогда $(a, b)$ равен $x_n$, последнему ненулевому члену этой последовательности.
		\end{Evc}
		\begin{proof}
			Поймем, что такие $r_1, r_2, r_3, r_4, \cdots r_n$ - существуют, причем единственно: всегда можно найти остаток $m$ (причем единственным образом) при делении $r_k$ на $r_{k + 1}$, если $r_{k + 1} \ne 0$, причем $a > b > r_k > r_{k + 1} > m$, т.е. каждый следующий член последовательности строго меньше предыдущего, но т.к. числа ее составляющие - целые, то убывать бесконечно она не может, а значит $\exists x_{n + 1} = 0$ - последний член последовательности.

			Докажем тогда, что если $x_n$ - последний не нулевой член последовательности, то $(a, b) = (x_n, 0) = x_n \ne 0$. Для этого заметим две вещи:
			\begin{enumerate}
				\item $r \ne 0 \Rightarrow (r, 0) = |r|$ так как 0 делится на любое целое число, кроме нуля.

				\item Пусть $a = bq + r$, тогда $(a,\ b) = (b,\ r)$.
				Пусть $k$ — любой общий делитель чисел $a$ и $b$, не обязательно наибольший, тогда $a = t_1k$ и $b = t_2k$, где $t_1$ и $t_2$ — целые числа из определения.

				Тогда $k$ является также общим делителем чисел $b$ и $r$, так как $b$ делится на $k$ по определению, а $r = a - b\cdot q = (t_1 - t_2\cdot q)\cdot k$ (выражение в скобках есть целое число, следовательно, $k$ делит $r$ без остатка). 
				
				Обратное также верно. Любой делитель $k$ чисел $b$ и $r$ так же является делителем $a$ и $b$: $a = b \cdot q + r = k\cdot (b\p q + r\p)$$\Rightarrow$ $k|a$.
				
				Следовательно, все общие делители пар чисел $a$, $b$ и $b$, $r$совпадают. Другими словами, нет общего делителя у чисел $a$, $b$, который не был бы также делителем $b$, $r$, и наоборот.
				
				В частности, наибольший общий делитель остается тем же самым. Что и требовалось доказать.
			\end{enumerate}

			Тогда по построению последовательности $\{x_i\}: (x_0,\ x_1) = (x_1,\ x_2) = (x_2,\ x_3) = \ldots = (x_n,\ 0) = x_n$.
		\end{proof}
		\begin{Evc}[Расширенный алгоритм Евклида] 
			Формулы для $x_i$ могут быть переписаны следующим образом:
			$x_0 = aq_0 + bp_0$,
			$x_1 = aq_1 + bp_1$,
			$x_2 = aq_2 + bp_2$
			$x_3 = aq_3 + bp_3$
	 		$\vdots$
			$(a,\ b) = x_n = as + bt$
		\end{Evc}
		\begin{proof}
			Докажем по индукции по $n$. 

			\textit{База.} $x_0 = a + b \cdot 0$, $x_1 = a \cdot 0 + b$. Т.е. $q_0 = P_1 = 1,\ p_0 = q_1 = 0$

			\textit{Предположение.} Пусть $x_{k - 2} = aq_{k - 2} + bp_{k - 2}$ и $x_{k - 1} = aq_{k - 1} + bp_{k - 1}$.

			\textit{Шаг.} Докажем, что $x_k = aq_{k} + bp_{k}$, где $q_k,\ p_k$ - целые. Мы помним, что $x_k$ - остаток от деления $x_{k - 2}$ на $x_{k - 1}$, значит по определнию: $m\cdot x_{k - 1} + x_k = x_{k - 2}$, где $m$ - какое-то целое число. Тогда $x_k = x_{k - 2} - m \cdot x_{k - 1}$, по п.и., $x_k = aq_{k - 2} + bp_{k - 2} - m(aq_{k - 1} + bp_{k - 1}) = a(q_{k - 2} - mq_{k - 1}) + b(p_{k - 2} - mp_{k - 1}) = aq_{k} + bp_{k}$.

			Таким образом каждое из чисел $x_i$ представимо в виде линейной комбинации $a$ и $b$ (В частности, если $(a,\ b) = 1$, то $\exists x,\ y: ax + by = 1$).
		\end{proof}

\end{document}
